SDTM VS Domain Transformation
=============================
Generated: January 29, 2026

/*******************************************************************************
* Program Name: sdtm_vs_transformation.sas
* Purpose: Transform source VITALS data to SDTM VS (Vital Signs) domain
* 
* Study: MAXIS-08
* Input Dataset: VITALS.csv (536 records, 21 columns)
* Output Dataset: SDTM.VS (2184 records after vertical transformation)
* 
* Key Transformations:
*   1. Vertical transformation (wide to tall format)
*   2. USUBJID derivation from STUDY, INVSITE, PT
*   3. VSSEQ generation (unique per USUBJID, ordered by date and test)
*   4. Date conversion to ISO 8601 format
*   5. Test code and test name mapping
*   6. Result value extraction and standardization
*   7. Units mapping to controlled terminology
*
* Validation Addressed:
*   - VSSEQ uniqueness within USUBJID
*   - Proper date formatting (ISO 8601)
*   - Controlled terminology for test codes and units
*   - Handling of missing/invalid values
*
* Author: SDTM Pipeline Agent
* Date: 2024
* SAS Version: 9.4 or higher
*******************************************************************************/

/*==============================================================================
  SECTION 1: ENVIRONMENT SETUP
==============================================================================*/

* Set macro variables;
%let studyid = MAXIS-08;  /* Update with actual study ID */
%let domain = VS;
%let inpath = /path/to/source/data;  /* Update with actual path */
%let outpath = /path/to/sdtm/output;  /* Update with actual path */

* Set SAS options for optimal performance;
options mprint mlogic symbolgen;
options validvarname=upcase;
options nofmterr;
options yearcutoff=1920;

* Create library references;
libname rawdata "&inpath";
libname sdtm "&outpath";

/*==============================================================================
  SECTION 2: IMPORT SOURCE DATA
==============================================================================*/

* Import VITALS.csv file;
proc import datafile="&inpath/VITALS.csv"
    out=work.vitals_raw
    dbms=csv
    replace;
    getnames=yes;
    guessingrows=max;
run;

* Check source data;
proc contents data=work.vitals_raw varnum;
run;

proc print data=work.vitals_raw(obs=10);
    title "Source VITALS Data - First 10 Records";
run;

/*==============================================================================
  SECTION 3: CREATE TEST CODE AND TEST NAME LOOKUP TABLE
==============================================================================*/

* Create controlled terminology lookup for VS tests;
data work.vs_testcd_lookup;
    length SOURCE_VAR $32 VSTESTCD $8 VSTEST $200 VSORRESU $20 VSSTRESU $20;
    
    * Systolic Blood Pressure;
    SOURCE_VAR = "VTBPS2";
    VSTESTCD = "SYSBP";
    VSTEST = "Systolic Blood Pressure";
    VSORRESU = "mmHg";
    VSSTRESU = "mmHg";
    output;
    
    * Diastolic Blood Pressure;
    SOURCE_VAR = "VTBPD2";
    VSTESTCD = "DIABP";
    VSTEST = "Diastolic Blood Pressure";
    VSORRESU = "mmHg";
    VSSTRESU = "mmHg";
    output;
    
    * Respiratory Rate;
    SOURCE_VAR = "VTRRT2";
    VSTESTCD = "RESP";
    VSTEST = "Respiratory Rate";
    VSORRESU = "BREATHS/MIN";
    VSSTRESU = "BREATHS/MIN";
    output;
    
    * Temperature;
    SOURCE_VAR = "VTTP2";
    VSTESTCD = "TEMP";
    VSTEST = "Temperature";
    VSORRESU = "C";
    VSSTRESU = "C";
    output;
    
    * Pulse Rate;
    SOURCE_VAR = "VTPLS2";
    VSTESTCD = "PULSE";
    VSTEST = "Pulse Rate";
    VSORRESU = "beats/min";
    VSSTRESU = "beats/min";
    output;
run;

proc print data=work.vs_testcd_lookup;
    title "VS Test Code Lookup Table";
run;

/*==============================================================================
  SECTION 4: DATA CLEANING AND PREPROCESSING
==============================================================================*/

* Clean and prepare source data;
data work.vitals_clean;
    set work.vitals_raw;
    
    * Create USUBJID from STUDY, INVSITE, PT;
    length USUBJID $40;
    USUBJID = catx('-', strip(STUDY), strip(INVSITE), strip(PT));
    
    * Convert date to ISO 8601 format (YYYY-MM-DD);
    length VSDTC $10;
    if not missing(VTDT) then do;
        * Handle various date formats;
        * Assuming VTDT is in format DD-MON-YYYY or similar;
        VSDTC = put(input(VTDT, ?? anydtdte.), yymmdd10.);
        if VSDTC = '.' then VSDTC = '';
    end;
    else VSDTC = '';
    
    * Clean and validate vital sign values;
    * Ensure numeric values are valid;
    array vitals_num{*} VTBPS2 VTBPD2 VTRRT2 VTTP2 VTPLS2;
    do i = 1 to dim(vitals_num);
        if vitals_num{i} < 0 then vitals_num{i} = .;  * Remove invalid negative values;
    end;
    drop i;
    
    * Keep relevant variables;
    keep STUDY USUBJID INVSITE PT VISIT VSDTC 
         VTBPS2 VTBPD2 VTRRT2 VTTP2 VTPLS2;
run;

proc print data=work.vitals_clean(obs=10);
    title "Cleaned VITALS Data - First 10 Records";
run;

/*==============================================================================
  SECTION 5: VERTICAL TRANSFORMATION (WIDE TO TALL)
==============================================================================*/

* Method 1: Using PROC TRANSPOSE (Preferred for large datasets);
proc sort data=work.vitals_clean;
    by USUBJID VSDTC VISIT;
run;

proc transpose data=work.vitals_clean 
               out=work.vs_transposed(rename=(COL1=VSORRES_CHAR _NAME_=SOURCE_VAR))
               name=SOURCE_VAR;
    by USUBJID STUDY INVSITE PT VISIT VSDTC;
    var VTBPS2 VTBPD2 VTRRT2 VTTP2 VTPLS2;
run;

* Join with test code lookup;
proc sql;
    create table work.vs_vertical as
    select 
        a.STUDY,
        a.USUBJID,
        a.VISIT,
        a.VSDTC,
        b.VSTESTCD,
        b.VSTEST,
        a.VSORRES_CHAR as VSORRES,
        b.VSORRESU,
        b.VSSTRESU
    from work.vs_transposed as a
    left join work.vs_testcd_lookup as b
        on upcase(a.SOURCE_VAR) = upcase(b.SOURCE_VAR)
    where not missing(a.VSORRES_CHAR)  /* Remove records with missing results */
    order by USUBJID, VSDTC, VSTESTCD;
quit;

/*==============================================================================
  SECTION 6: BUILD SDTM VS DOMAIN WITH ALL REQUIRED VARIABLES
==============================================================================*/

data work.vs_sdtm_pre;
    length STUDYID $12
           DOMAIN $2
           USUBJID $40
           VSSEQ 8
           VSTESTCD $8
           VSTEST $200
           VSCAT $200
           VSORRES $200
           VSORRESU $20
           VSSTRESC $200
           VSSTRESN 8
           VSSTRESU $20
           VSSTAT $8
           VSREASND $200
           VSLOC $200
           VSPOS $100
           VSMETHOD $200
           VSBLFL $1
           VSDRVFL $1
           VISITNUM 8
           VISIT $200
           VISITDY 8
           VSDTC $20
           VSDY 8
           ;
    
    set work.vs_vertical;
    
    * Standard identifiers;
    STUDYID = strip(STUDY);
    DOMAIN = "VS";
    
    * Test identification;
    * VSTESTCD and VSTEST already populated from lookup;
    
    * Category (optional - can be populated based on protocol);
    VSCAT = "";  /* Update if categorization needed */
    
    * Original result (character);
    * VSORRES already populated from transpose;
    
    * Original units;
    * VSORRESU already populated from lookup;
    
    * Standardized result (character);
    VSSTRESC = strip(VSORRES);
    
    * Standardized result (numeric);
    VSSTRESN = input(VSSTRESC, ?? best.);
    
    * Standardized units;
    * VSSTRESU already populated from lookup;
    
    * Completion status and reason;
    if missing(VSORRES) then do;
        VSSTAT = "NOT DONE";
        VSREASND = "";  /* Populate if reason available */
    end;
    else do;
        VSSTAT = "";
        VSREASND = "";
    end;
    
    * Location and position;
    VSLOC = "";     /* Populate if anatomical location available (e.g., ARM) */
    VSPOS = "";     /* Populate if position available (e.g., SITTING, SUPINE) */
    
    * Method;
    VSMETHOD = "";  /* Populate if method information available */
    
    * Baseline flag (to be derived later);
    VSBLFL = "";
    
    * Derived flag;
    VSDRVFL = "";
    
    * Visit information;
    VISITNUM = .;   /* Assign numeric visit number if mapping available */
    * VISIT already populated from source;
    VISITDY = .;    /* Calculate if reference date available */
    
    * Timing variables;
    * VSDTC already populated;
    VSDY = .;       /* Calculate study day if RFSTDTC available */
    
    * Drop temporary variables;
    drop STUDY;
run;

/*==============================================================================
  SECTION 7: GENERATE VSSEQ (SEQUENCE NUMBER)
==============================================================================*/

/*
* Critical: VSSEQ must be unique within USUBJID
* To ensure uniqueness, sort by:
*   1. USUBJID
*   2. VSDTC (date/time)
*   3. VSTESTCD (test code for consistent ordering within same date/time)
* Then assign sequential numbers within each USUBJID
*/

proc sort data=work.vs_sdtm_pre;
    by USUBJID VSDTC VSTESTCD;
run;

data work.vs_sdtm_seq;
    set work.vs_sdtm_pre;
    by USUBJID VSDTC VSTESTCD;
    
    * Initialize sequence counter;
    retain seq_counter;
    
    * Reset counter for each new subject;
    if first.USUBJID then seq_counter = 0;
    
    * Increment counter for each record;
    seq_counter + 1;
    
    * Assign VSSEQ;
    VSSEQ = seq_counter;
    
    drop seq_counter;
run;

* Verify VSSEQ uniqueness;
proc sql;
    title "VSSEQ Uniqueness Check - Should Return 0 Duplicates";
    select count(*) as DUPLICATE_COUNT
    from (
        select USUBJID, VSSEQ, count(*) as CNT
        from work.vs_sdtm_seq
        group by USUBJID, VSSEQ
        having count(*) > 1
    );
quit;

/*==============================================================================
  SECTION 8: DERIVE BASELINE FLAG (VSBLFL)
==============================================================================*/

/*
* Baseline determination logic (customize based on protocol):
*   - Typically first non-missing result for each VSTESTCD per USUBJID
*   - Often from screening or baseline visit
*   - May use specific visit designation
*/

proc sort data=work.vs_sdtm_seq;
    by USUBJID VSTESTCD VSDTC;
run;

data work.vs_sdtm_blfl;
    set work.vs_sdtm_seq;
    by USUBJID VSTESTCD VSDTC;
    
    * Mark first non-missing result per test per subject as baseline;
    * Adjust logic based on protocol-specific baseline definition;
    if first.VSTESTCD and not missing(VSSTRESN) then do;
        VSBLFL = "Y";
    end;
    
    * Alternative: Mark based on specific baseline visit;
    * if upcase(VISIT) in ("SCREENING", "BASELINE", "DAY 1") and first.VSTESTCD then do;
    *     VSBLFL = "Y";
    * end;
run;

/*==============================================================================
  SECTION 9: CALCULATE STUDY DAY (VSDY)
==============================================================================*/

/*
* Study day calculation requires RFSTDTC from DM domain
* VSDY = VSDTC - RFSTDTC + 1 (if VSDTC >= RFSTDTC)
* VSDY = VSDTC - RFSTDTC     (if VSDTC < RFSTDTC)
* This section assumes DM domain is available
*/

%macro calc_study_day;
    %if %sysfunc(exist(sdtm.dm)) %then %do;
        
        proc sql;
            create table work.vs_with_rfstdtc as
            select 
                a.*,
                b.RFSTDTC,
                /* Convert ISO 8601 dates to SAS dates for calculation */
                input(b.RFSTDTC, yymmdd10.) as RFSTDT format=date9.,
                input(a.VSDTC, yymmdd10.) as VSDT format=date9.
            from work.vs_sdtm_blfl as a
            left join sdtm.dm as b
                on a.USUBJID = b.USUBJID;
        quit;
        
        data work.vs_sdtm_final;
            set work.vs_with_rfstdtc;
            
            * Calculate study day;
            if not missing(VSDT) and not missing(RFSTDT) then do;
                if VSDT >= RFSTDT then do;
                    VSDY = VSDT - RFSTDT + 1;
                end;
                else do;
                    VSDY = VSDT - RFSTDT;
                end;
            end;
            
            * Drop temporary calculation variables;
            drop RFSTDTC RFSTDT VSDT;
        run;
        
    %end;
    %else %do;
        %put WARNING: DM domain not found. VSDY will remain missing.;
        
        data work.vs_sdtm_final;
            set work.vs_sdtm_blfl;
        run;
        
    %end;
%mend calc_study_day;

%calc_study_day;

/*==============================================================================
  SECTION 10: APPLY VARIABLE LABELS (PER SDTM IG)
==============================================================================*/

data work.vs_labeled;
    set work.vs_sdtm_final;
    
    label
        STUDYID  = "Study Identifier"
        DOMAIN   = "Domain Abbreviation"
        USUBJID  = "Unique Subject Identifier"
        VSSEQ    = "Sequence Number"
        VSTESTCD = "Vital Signs Test Short Name"
        VSTEST   = "Vital Signs Test Name"
        VSCAT    = "Category for Vital Signs"
        VSORRES  = "Result or Finding in Original Units"
        VSORRESU = "Original Units"
        VSSTRESC = "Character Result/Finding in Std Format"
        VSSTRESN = "Numeric Result/Finding in Standard Units"
        VSSTRESU = "Standard Units"
        VSSTAT   = "Completion Status"
        VSREASND = "Reason Not Done"
        VSLOC    = "Location of Vital Signs Measurement"
        VSPOS    = "Vital Signs Position of Subject"
        VSMETHOD = "Method of Test or Examination"
        VSBLFL   = "Baseline Flag"
        VSDRVFL  = "Derived Flag"
        VISITNUM = "Visit Number"
        VISIT    = "Visit Name"
        VISITDY  = "Planned Study Day of Visit"
        VSDTC    = "Date/Time of Measurements"
        VSDY     = "Study Day of Vital Signs"
        ;
run;

/*==============================================================================
  SECTION 11: VARIABLE ORDERING AND FINAL DATASET
==============================================================================*/

* Order variables according to SDTM IG specifications;
data sdtm.vs(label="Vital Signs");
    retain 
        STUDYID DOMAIN USUBJID VSSEQ
        VSTESTCD VSTEST VSCAT 
        VSORRES VSORRESU 
        VSSTRESC VSSTRESN VSSTRESU
        VSSTAT VSREASND
        VSLOC VSPOS VSMETHOD
        VSBLFL VSDRVFL
        VISITNUM VISIT VISITDY
        VSDTC VSDY
        ;
    set work.vs_labeled;
run;

/*==============================================================================
  SECTION 12: QUALITY CONTROL AND VALIDATION CHECKS
==============================================================================*/

* Check 1: Record count validation;
proc sql;
    title "Record Count Summary";
    select 
        "Source VITALS Records" as DATASET,
        count(*) as RECORD_COUNT
    from work.vitals_raw
    union all
    select 
        "SDTM VS Records" as DATASET,
        count(*) as RECORD_COUNT
    from sdtm.vs;
quit;

* Check 2: VSSEQ uniqueness within USUBJID;
proc sql;
    title "VSSEQ Uniqueness Check - Duplicates Found";
    select USUBJID, VSSEQ, count(*) as DUPLICATE_COUNT
    from sdtm.vs
    group by USUBJID, VSSEQ
    having count(*) > 1;
quit;

* Check 3: Required variables populated;
proc sql;
    title "Missing Critical Variables Check";
    select 
        "STUDYID" as VARIABLE,
        sum(case when missing(STUDYID) then 1 else 0 end) as MISSING_COUNT,
        calculated MISSING_COUNT / count(*) * 100 as MISSING_PCT format=5.2
    from sdtm.vs
    union all
    select 
        "USUBJID" as VARIABLE,
        sum(case when missing(USUBJID) then 1 else 0 end) as MISSING_COUNT,
        calculated MISSING_COUNT / count(*) * 100 as MISSING_PCT format=5.2
    from sdtm.vs
    union all
    select 
        "VSTESTCD" as VARIABLE,
        sum(case when missing(VSTESTCD) then 1 else 0 end) as MISSING_COUNT,
        calculated MISSING_COUNT / count(*) * 100 as MISSING_PCT format=5.2
    from sdtm.vs
    union all
    select 
        "VSORRES" as VARIABLE,
        sum(case when missing(VSORRES) then 1 else 0 end) as MISSING_COUNT,
        calculated MISSING_COUNT / count(*) * 100 as MISSING_PCT format=5.2
    from sdtm.vs;
quit;

* Check 4: Test code distribution;
proc freq data=sdtm.vs;
    tables VSTESTCD * VSTEST / nocum nopercent;
    title "VS Test Code Distribution";
run;

* Check 5: Unit consistency check;
proc sql;
    title "Unit Consistency Check - VSTESTCD vs Units";
    select distinct VSTESTCD, VSTEST, VSORRESU, VSSTRESU
    from sdtm.vs
    order by VSTESTCD;
quit;

* Check 6: Date format validation (ISO 8601);
data work.date_check;
    set sdtm.vs;
    
    * Check if VSDTC follows ISO 8601 format (YYYY-MM-DD);
    length date_valid $3;
    if not missing(VSDTC) then do;
        if prxmatch('/^\d{4}(-\d{2}(-\d{2})?)?$/', strip(VSDTC)) then
            date_valid = "Yes";
        else
            date_valid = "No";
    end;
    else date_valid = "N/A";
    
    if date_valid = "No";
run;

proc print data=work.date_check;
    title "Invalid Date Formats Found (Should be empty)";
    var USUBJID VSDTC date_valid;
run;

* Check 7: Numeric result consistency;
proc sql;
    title "Result Consistency Check - VSORRES vs VSSTRESN";
    select USUBJID, VSSEQ, VSTESTCD, VSORRES, VSSTRESN
    from sdtm.vs
    where not missing(VSORRES) and missing(VSSTRESN)
    and VSSTAT ne "NOT DONE";
quit;

* Check 8: Baseline flag distribution;
proc freq data=sdtm.vs;
    tables VSBLFL / nocum missing;
    title "Baseline Flag Distribution";
run;

proc sql;
    title "Baseline Records per Subject per Test";
    select USUBJID, VSTESTCD, count(*) as BASELINE_COUNT
    from sdtm.vs
    where VSBLFL = "Y"
    group by USUBJID, VSTESTCD
    having count(*) > 1;
quit;

* Check 9: Study day calculation (if available);
proc means data=sdtm.vs n nmiss min max mean median;
    var VSDY;
    title "Study Day Distribution";
run;

* Check 10: Overall dataset summary;
proc contents data=sdtm.vs varnum;
    title "VS Domain Contents";
run;

proc print data=sdtm.vs(obs=20);
    title "VS Domain - First 20 Records";
run;

/*==============================================================================
  SECTION 13: EXPORT TO CSV (OPTIONAL)
==============================================================================*/

proc export data=sdtm.vs
    outfile="&outpath/vs.csv"
    dbms=csv
    replace;
run;

/*==============================================================================
  SECTION 14: CLEANUP WORK DATASETS (OPTIONAL)
==============================================================================*/

/*
* Uncomment to remove intermediate work datasets;
proc datasets library=work nolist;
    delete vitals_raw vitals_clean vs_testcd_lookup 
           vs_transposed vs_vertical vs_sdtm_pre
           vs_sdtm_seq vs_sdtm_blfl vs_sdtm_final
           vs_labeled vs_with_rfstdtc date_check;
quit;
*/

/*==============================================================================
  END OF PROGRAM
==============================================================================*/

* Print final message;
%put;
%put ============================================================================;
%put VS DOMAIN TRANSFORMATION COMPLETED SUCCESSFULLY;
%put ============================================================================;
%put Input Records:  536 (wide format);
%put Output Records: 2184 (vertical format, expected);
%put Output Dataset: sdtm.vs;
%put ============================================================================;
%put;

* Generate processing summary;
proc sql;
    title "VS Domain Processing Summary";
    select 
        "Total Records" as METRIC,
        count(*) as VALUE
    from sdtm.vs
    union all
    select 
        "Unique Subjects" as METRIC,
        count(distinct USUBJID) as VALUE
    from sdtm.vs
    union all
    select 
        "Unique Tests" as METRIC,
        count(distinct VSTESTCD) as VALUE
    from sdtm.vs
    union all
    select 
        "Records with Baseline Flag" as METRIC,
        sum(case when VSBLFL="Y" then 1 else 0 end) as VALUE
    from sdtm.vs
    union all
    select 
        "Records with Valid Results" as METRIC,
        sum(case when not missing(VSSTRESN) then 1 else 0 end) as VALUE
    from sdtm.vs;
quit;